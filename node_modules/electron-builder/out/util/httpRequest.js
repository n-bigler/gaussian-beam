"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

// only https proxy
let proxyFromNpm = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
        let data = "";
        try {
            data = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join((0, (_os || _load_os()).homedir)(), ".npmrc"), "utf-8");
        } catch (ignored) {
            return null;
        }
        if (!data) {
            return null;
        }
        try {
            const config = (0, (_ini || _load_ini()).parse)(data);
            return config["https-proxy"] || config.proxy;
        } catch (e) {
            // used in nsis auto-updater, do not use .util.warn here
            console.warn(e);
            return null;
        }
    });

    return function proxyFromNpm() {
        return _ref.apply(this, arguments);
    };
})();
// only https url


let createAgent = (() => {
    var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
        let proxyString = process.env.npm_config_https_proxy || process.env.HTTPS_PROXY || process.env.https_proxy || process.env.npm_config_proxy;
        if (!proxyString) {
            proxyString = yield proxyFromNpm();
            if (!proxyString) {
                return null;
            }
        }
        const proxy = (0, (_url || _load_url()).parse)(proxyString);
        const proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
        return require("tunnel-agent")[`httpsOver${ proxyProtocol }`]({
            proxy: {
                port: proxy.port || (proxyProtocol === "Https" ? 443 : 80),
                host: proxy.hostname,
                proxyAuth: proxy.auth
            }
        });
    });

    return function createAgent() {
        return _ref2.apply(this, arguments);
    };
})();
//# sourceMappingURL=httpRequest.js.map


exports.download = download;
exports.addTimeOutHandler = addTimeOutHandler;

var _https;

function _load_https() {
    return _https = _interopRequireWildcard(require("https"));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _url;

function _load_url() {
    return _url = require("url");
}

var _path = _interopRequireWildcard(require("path"));

var _crypto;

function _load_crypto() {
    return _crypto = require("crypto");
}

var _stream;

function _load_stream() {
    return _stream = require("stream");
}

var _os;

function _load_os() {
    return _os = require("os");
}

var _ini;

function _load_ini() {
    return _ini = require("ini");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const maxRedirects = 10;
let httpsAgent = null;
function download(url, destination, options) {
    return (httpsAgent || (httpsAgent = createAgent())).then(it => new (_bluebirdLstC2 || _load_bluebirdLstC2()).default(function (resolve, reject) {
        doDownload(url, destination, 0, options || {}, it, error => {
            if (error == null) {
                resolve(destination);
            } else {
                reject(error);
            }
        });
    }));
}
function addTimeOutHandler(request, callback) {
    request.on("socket", function (socket) {
        socket.setTimeout(60 * 1000, () => {
            callback(new Error("Request timed out"));
            request.abort();
        });
    });
}
function doDownload(url, destination, redirectCount, options, agent, callback) {
    const ensureDirPromise = options.skipDirCreation ? (_bluebirdLstC2 || _load_bluebirdLstC2()).default.resolve() : (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(destination));
    const parsedUrl = (0, (_url || _load_url()).parse)(url);
    // user-agent must be specified, otherwise some host can return 401 unauthorised
    const request = (_https || _load_https()).request({
        hostname: parsedUrl.hostname,
        path: parsedUrl.path,
        headers: {
            "User-Agent": "electron-builder"
        },
        agent: agent
    }, response => {
        if (response.statusCode >= 400) {
            callback(new Error(`Cannot download "${ url }", status ${ response.statusCode }: ${ response.statusMessage }`));
            return;
        }
        const redirectUrl = response.headers.location;
        if (redirectUrl != null) {
            if (redirectCount < maxRedirects) {
                doDownload(redirectUrl, destination, redirectCount++, options, agent, callback);
            } else {
                callback(new Error("Too many redirects (> " + maxRedirects + ")"));
            }
            return;
        }
        const sha2Header = response.headers["X-Checksum-Sha2"];
        if (sha2Header != null && options.sha2 != null) {
            // todo why bintray doesn't send this header always
            if (sha2Header == null) {
                throw new Error("checksum is required, but server response doesn't contain X-Checksum-Sha2 header");
            } else if (sha2Header !== options.sha2) {
                throw new Error(`checksum mismatch: expected ${ options.sha2 } but got ${ sha2Header } (X-Checksum-Sha2 header)`);
            }
        }
        ensureDirPromise.then(() => {
            const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(destination);
            if (options.sha2 == null) {
                response.pipe(fileOut);
            } else {
                response.pipe(new DigestTransform(options.sha2)).pipe(fileOut);
            }
            fileOut.on("finish", () => fileOut.close(callback));
        }).catch(callback);
        let ended = false;
        response.on("end", () => {
            ended = true;
        });
        response.on("close", () => {
            if (!ended) {
                callback(new Error("Request aborted"));
            }
        });
    });
    addTimeOutHandler(request, callback);
    request.on("error", callback);
    request.end();
}
class DigestTransform extends (_stream || _load_stream()).Transform {
    constructor(expected) {
        super();
        this.expected = expected;
        this.digester = (0, (_crypto || _load_crypto()).createHash)("sha256");
    }
    _transform(chunk, encoding, callback) {
        this.digester.update(chunk);
        callback(null, chunk);
    }
    _flush(callback) {
        const hash = this.digester.digest("hex");
        callback(hash === this.expected ? null : new Error(`SHA2 checksum mismatch, expected ${ this.expected }, got ${ hash }`));
    }
}