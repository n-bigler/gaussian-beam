"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _platformPackager;

function _load_platformPackager() {
    return _platformPackager = require("../platformPackager");
}

var _metadata;

function _load_metadata() {
    return _metadata = require("../metadata");
}

var _log;

function _load_log() {
    return _log = require("../util/log");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _util;

function _load_util() {
    return _util = require("../util/util");
}

var _os;

function _load_os() {
    return _os = require("os");
}

var _targetFactory;

function _load_targetFactory() {
    return _targetFactory = require("./targetFactory");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class SnapTarget extends (_targetFactory || _load_targetFactory()).Target {
    constructor(name, packager, helper, outDir) {
        super(name);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.devMetadata.build[this.name]);
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            (0, (_log || _load_log()).log)(`Building Snap for arch ${ (_metadata || _load_metadata()).Arch[arch] }`);
            const packager = _this.packager;
            const appInfo = packager.appInfo;
            const options = _this.options;
            const snapDir = `${ appOutDir }-snap`;
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(snapDir);
            const snap = {};
            snap.name = packager.executableName;
            snap.version = appInfo.version;
            snap.summary = options.summary || appInfo.productName;
            snap.description = _this.helper.getDescription(options);
            snap.confinement = options.confinement || "strict";
            snap.grade = options.grade || "stable";
            yield _this.helper.icons;
            if (_this.helper.maxIconPath != null) {
                snap.icon = "setup/gui/icon.png";
                yield (0, (_fsExtraP || _load_fsExtraP()).copy)(_this.helper.maxIconPath, _path.join(snapDir, "setup", "gui", "icon.png"));
            }
            if (options.assumes != null) {
                if (!Array.isArray(options.assumes)) {
                    throw new Error("snap.assumes must be an array of strings");
                }
                snap.assumes = options.assumes;
            }
            snap.apps = {
                [snap.name]: {
                    command: `desktop-launch $SNAP/${ packager.executableName }`,
                    plugs: ["home", "unity7", "x11", "browser-support", "network", "gsettings", "pulseaudio", "opengl"]
                }
            };
            yield _this.helper.computeDesktopEntry(_this.options, "$snap.$app", _path.join(snapDir, "setup", "gui", `${ snap.name }.desktop`), {
                "Icon": "${SNAP}/meta/gui/icon.png"
            });
            const isUseDocker = process.platform !== "linux";
            snap.parts = {
                app: {
                    plugin: "dump",
                    "stage-packages": ["libappindicator1", "libdbusmenu-glib4", "libnotify4", "libunity9", "libgconf-2-4", "libnss3", "libxss1", "fontconfig-config", "libnotify-bin"],
                    source: isUseDocker ? `/out/${ _path.basename(snapDir) }` : appOutDir,
                    filesets: {
                        app: [`${ appOutDir }/*`]
                    },
                    after: ["desktop-glib-only"]
                }
            };
            const snapcraft = _path.join(snapDir, "snapcraft.yaml");
            yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(snapcraft, (0, (_jsYaml || _load_jsYaml()).safeDump)(snap));
            // const args = ["snapcraft", path.relative(snapDir)]
            // snap /out/${path.basename(snapDir)} --output /out/${path.basename(resultFile)}
            if (isUseDocker) {
                yield (0, (_util || _load_util()).spawn)("docker", ["run", "--rm", "-v", `${ packager.info.projectDir }:/project`, "-v", `${ (0, (_os || _load_os()).homedir)() }/.electron:/root/.electron`,
                // dist dir can be outside of project dir
                "-v", `${ _this.outDir }:/out`, "-w", `/out/${ _path.basename(snapDir) }`, "electronuserland/electron-builder:latest", "/bin/bash", "-c", `env && snapcraft snap`], {
                    cwd: packager.info.projectDir
                });
            } else {
                yield (0, (_util || _load_util()).spawn)("snapcraft", ["snap"], {
                    cwd: snapDir
                });
            }
            const snapName = `${ snap.name }_${ snap.version }_${ (0, (_platformPackager || _load_platformPackager()).toDebArch)(arch) }.snap`;
            const resultFile = _path.join(_this.outDir, snapName);
            yield (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(snapDir, snapName), resultFile);
            packager.dispatchArtifactCreated(resultFile);
        })();
    }
}
exports.default = SnapTarget; //# sourceMappingURL=snap.js.map