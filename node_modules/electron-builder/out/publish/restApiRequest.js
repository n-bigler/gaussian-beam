"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpError = undefined;
exports.githubRequest = githubRequest;
exports.bintrayRequest = bintrayRequest;
exports.request = request;
exports.doApiRequest = doApiRequest;

var _https;

function _load_https() {
    return _https = _interopRequireWildcard(require("https"));
}

var _httpRequest;

function _load_httpRequest() {
    return _httpRequest = require("../util/httpRequest");
}

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = _interopRequireDefault(require("bluebird-lst-c"));
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _debug2;

function _load_debug() {
    return _debug2 = _interopRequireDefault(require("debug"));
}

var _url;

function _load_url() {
    return _url = require("url");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const debug = (0, (_debug2 || _load_debug()).default)("electron-builder");
function githubRequest(path, token) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "GET";

    return request({ hostname: "api.github.com", path: path }, token, data, method);
}
function bintrayRequest(path, auth) {
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "GET";

    return request({ hostname: "api.bintray.com", path: path }, auth, data, method);
}
function request(url) {
    let token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "GET";

    const options = Object.assign({
        method: method,
        headers: {
            "User-Agent": "electron-builder"
        }
    }, url);
    if (url.hostname.indexOf("github") !== -1 && !url.path.endsWith(".yml")) {
        options.headers.Accept = "application/vnd.github.v3+json";
    }
    const encodedData = data == null ? null : new Buffer(JSON.stringify(data));
    if (encodedData != null) {
        options.method = "post";
        options.headers["Content-Type"] = "application/json";
        options.headers["Content-Length"] = encodedData.length;
    }
    return doApiRequest(options, token, it => it.end(encodedData));
}
function doApiRequest(options, token, requestProcessor) {
    let redirectCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    debug(`HTTPS request: ${ JSON.stringify(options, null, 2) }`);
    if (token != null) {
        options.headers.authorization = token.startsWith("Basic") ? token : `token ${ token }`;
    }
    return new (_bluebirdLstC || _load_bluebirdLstC()).default((resolve, reject, onCancel) => {
        const request = (_https || _load_https()).request(options, response => {
            try {
                if (response.statusCode === 404) {
                    // error is clear, we don't need to read detailed error description
                    reject(new HttpError(response, `method: ${ options.method } url: https://${ options.hostname }${ options.path }

Please double check that your authentication token is correct. Due to security reasons actual status maybe not reported, but 404.
`));
                } else if (response.statusCode === 204) {
                    // on DELETE request
                    resolve();
                    return;
                }
                const redirectUrl = response.headers.location;
                if (redirectUrl != null) {
                    if (redirectCount > 10) {
                        reject(new Error("Too many redirects (> 10)"));
                        return;
                    }
                    if (options.path.endsWith("/latest")) {
                        resolve({ location: redirectUrl });
                    } else {
                        doApiRequest(Object.assign({}, options, (0, (_url || _load_url()).parse)(redirectUrl)), token, requestProcessor).then(resolve).catch(reject);
                    }
                    return;
                }
                let data = "";
                response.setEncoding("utf8");
                response.on("data", chunk => {
                    data += chunk;
                });
                response.on("end", () => {
                    try {
                        const contentType = response.headers["content-type"];
                        const isJson = contentType != null && contentType.indexOf("json") !== -1;
                        if (response.statusCode >= 400) {
                            if (isJson) {
                                reject(new HttpError(response, JSON.parse(data)));
                            } else {
                                reject(new HttpError(response));
                            }
                        } else {
                            resolve(data.length === 0 ? null : isJson || !(options.path.indexOf(".yml") !== -1) ? JSON.parse(data) : (0, (_jsYaml || _load_jsYaml()).safeLoad)(data));
                        }
                    } catch (e) {
                        reject(e);
                    }
                });
            } catch (e) {
                reject(e);
            }
        });
        (0, (_httpRequest || _load_httpRequest()).addTimeOutHandler)(request, reject);
        request.on("error", reject);
        requestProcessor(request, reject);
        onCancel(() => request.abort());
    });
}
class HttpError extends Error {
    constructor(response) {
        let description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        super(response.statusCode + " " + response.statusMessage + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + JSON.stringify(response.headers, null, "  "));
        this.response = response;
        this.description = description;
    }
}
exports.HttpError = HttpError; //# sourceMappingURL=restApiRequest.js.map